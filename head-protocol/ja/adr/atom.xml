<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://input-output-hk.github.io/head-protocol/ja/adr</id>
    <title>Hydra: Head Protocol Blog</title>
    <updated>2021-06-05T00:00:00.000Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://input-output-hk.github.io/head-protocol/ja/adr"/>
    <subtitle>Hydra: Head Protocol Blog</subtitle>
    <icon>https://input-output-hk.github.io/head-protocol/ja/img/hydra.png</icon>
    <entry>
        <title type="html"><![CDATA[1. Record Architecture Decisions
]]></title>
        <id>1</id>
        <link href="https://input-output-hk.github.io/head-protocol/ja/adr/1"/>
        <updated>2021-06-05T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Status]]></summary>
        <content type="html"><![CDATA[<h2 class="anchor anchorWithStickyNavbar_mojV" id="status">Status<a class="hash-link" href="#status" title="見出しへの直接リンク">​</a></h2><p>Accepted</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="context">Context<a class="hash-link" href="#context" title="見出しへの直接リンク">​</a></h2><p>We are in search for a means to describe our technical architecture.</p><p>We are a small team working in a very lean and agile way (XP), so we naturally
prefer also light-weight documentation methods which also accomodate change
easily.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="decision">Decision<a class="hash-link" href="#decision" title="見出しへの直接リンク">​</a></h2><ul><li>We will use <em>Architecture Decision Records</em>, as described by Michael Nygard in
this
<a href="http://thinkrelevance.com/blog/2011/11/15/documenting-architecture-decisions" target="_blank" rel="noopener noreferrer">article</a>.</li><li>We will follow the convention of storing those ADRs as Markdown formatted
documents stored under <code>docs/adr</code> directory, as exemplified in Nat Pryce's
<a href="https://github.com/npryce/adr-tools" target="_blank" rel="noopener noreferrer">adr-tools</a>. This does not imply we will
be using <code>adr-tools</code> itself.</li></ul><h2 class="anchor anchorWithStickyNavbar_mojV" id="consequences">Consequences<a class="hash-link" href="#consequences" title="見出しへの直接リンク">​</a></h2><p>See Michael Nygard's article, linked above.</p>]]></content>
        <category label="Accepted" term="Accepted"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[2. Reactive Core
]]></title>
        <id>2</id>
        <link href="https://input-output-hk.github.io/head-protocol/ja/adr/2"/>
        <updated>2021-06-06T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Status]]></summary>
        <content type="html"><![CDATA[<h2 class="anchor anchorWithStickyNavbar_mojV" id="status">Status<a class="hash-link" href="#status" title="見出しへの直接リンク">​</a></h2><p>Accepted</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="context">Context<a class="hash-link" href="#context" title="見出しへの直接リンク">​</a></h2><p>We are looking for a way of expressing the Hydra Head protocol logic in a Hydra node.</p><p>The Hydra Head protocol is defined as a <em>State machine</em> in the paper, whose transitions are inputs that come from different sources which can emit outputs to other instances of the state machine or the mainchain. See the <a href="https://iohk.io/en/research/library/papers/hydrafast-isomorphic-state-channels/" target="_blank" rel="noopener noreferrer">FC2021</a> paper for details</p><p>It should also be easy to review / feed-back to researchers.</p><p>We are familiar with React's <a href="https://react-redux.js.org/" target="_blank" rel="noopener noreferrer">redux</a> way of structuring applications, which in turn is inspired by <a href="https://guide.elm-lang.org/architecture/" target="_blank" rel="noopener noreferrer">The Elm Architecture</a> which itself is a simplification of <a href="https://en.wikipedia.org/wiki/Functional_reactive_programming" target="_blank" rel="noopener noreferrer">Functional Reactive Programming</a> principles.</p><p>We have experienced benefits with <em>Event Sourcing</em> in the domain of persistence in the past</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="decision">Decision<a class="hash-link" href="#decision" title="見出しへの直接リンク">​</a></h2><p>Implements the Hydra Head core logic as a <em>loop</em> that:</p><ol><li>Consumes <em>input events</em> from an event <em>queue</em>,</li><li>Applies each <em>event</em> to the current <em>state</em> yielding potentially an <em>updated state</em> and a sequence of <em>effects</em>,</li><li>Execute all <em>effects</em>.</li></ol><h2 class="anchor anchorWithStickyNavbar_mojV" id="consequences">Consequences<a class="hash-link" href="#consequences" title="見出しへの直接リンク">​</a></h2><p>The internal state is only ever changed through <em>Events</em>.</p><p>The core state machine <em>transition</em> function <em>is pure</em> and reviewing it requires minimal Haskell knowledge.</p><p>Side-effects are all handled at the level of the <code>Node</code>.</p>]]></content>
        <category label="Accepted" term="Accepted"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[3. Asynchronous Duplex Client API]]></title>
        <id>3</id>
        <link href="https://input-output-hk.github.io/head-protocol/ja/adr/3"/>
        <updated>2021-06-07T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Status]]></summary>
        <content type="html"><![CDATA[<h2 class="anchor anchorWithStickyNavbar_mojV" id="status">Status<a class="hash-link" href="#status" title="見出しへの直接リンク">​</a></h2><p>Accepted</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="context">Context<a class="hash-link" href="#context" title="見出しへの直接リンク">​</a></h2><p>The <a href="/head-protocol/ja/adr/2"><em>reactive</em> nature of the Hydra node</a> means that
clients produce a <em>stream</em> of <em>inputs</em> to a node which in turns issues a stream
of <em>outputs</em> representing the outcome of previous inputs or resulting from
interaction with peers in the network.</p><p>For example, a client may send a <em>command</em> as <em>input</em>, upon which the node might
do something. When that something is finished, a <em>output</em> does indicate that.
However, there might also be an <em>output</em> emitted to the client when another peer
interacted with "our" node.</p><p>Queries, messages by clients which do only fetch information from the node, are
not in scope of this ADR.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="decision">Decision<a class="hash-link" href="#decision" title="見出しへの直接リンク">​</a></h2><ul><li>We use a single, full-duplex communication channel per client connected to a Hydra node</li><li>This is implemented using a simple <a href="https://datatracker.ietf.org/doc/html/rfc6455" target="_blank" rel="noopener noreferrer">Websocket</a> with messages corresponding to <code>Input</code>s and <code>Output</code>s.</li></ul><h2 class="anchor anchorWithStickyNavbar_mojV" id="consequences">Consequences<a class="hash-link" href="#consequences" title="見出しへの直接リンク">​</a></h2><ul><li>Clients needing a synchronous API need to implement it on top</li><li>Clients can receive <em>outputs</em> decorrelated from any <em>inputs</em> and at any time</li></ul>]]></content>
        <category label="Accepted" term="Accepted"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[4. Use Handle to model Effects
]]></title>
        <id>4</id>
        <link href="https://input-output-hk.github.io/head-protocol/ja/adr/4"/>
        <updated>2021-06-08T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Status]]></summary>
        <content type="html"><![CDATA[<h2 class="anchor anchorWithStickyNavbar_mojV" id="status">Status<a class="hash-link" href="#status" title="見出しへの直接リンク">​</a></h2><p>Accepted</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="context">Context<a class="hash-link" href="#context" title="見出しへの直接リンク">​</a></h2><p>Given we are structuring Hydra node as a <a href="/head-protocol/ja/adr/2">reactive core</a> we need a way to ensure a strict separation of pure and impure (or effectful) code.</p><p>We want to be able to test those impure/effectful parts of the code. This requires a means for exchanging the actual implementation for e.g. the function to send messages over a network.</p><p>Also we want the ability to swap implementations not only for testing, but also be able
to accommodate different usage scenarios, e.g. use a different middleware
depending on peer configuration.</p><p>In Haskell there are various common <em>patterns</em> to model effects:</p><ul><li><a href="http://okmij.org/ftp/tagless-final/index.html" target="_blank" rel="noopener noreferrer">Tagless final encoding</a> also known as <em>MTL-style</em> although using typeclasses to implement is <a href="https://www.foxhound.systems/blog/final-tagless/" target="_blank" rel="noopener noreferrer">not necessary</a>, whereby Effect(s) are expressed as typeclass(es) which are propagated as constraints</li><li><a href="https://reasonablypolymorphic.com/blog/freer-monads/" target="_blank" rel="noopener noreferrer">Free monads</a>, or any variant thereof like Eff, freer, extensible-effects, whereby effect(s) are expressed as ADTs which are <em>interpreted</em> in the context of an <em>Effect stack</em></li><li><a href="https://jaspervdj.be/posts/2018-03-08-handle-pattern.html" target="_blank" rel="noopener noreferrer">Handle</a> pattern also known as <em>record-of-functions</em> whereby effects are grouped together in a datatype with a single record constructor</li></ul><p>(These tradeoffs also appear in other functional languages like
<a href="https://medium.com/@dogwith1eye/prefer-records-of-functions-to-interfaces-d6413af4d2c3" target="_blank" rel="noopener noreferrer">F#</a>)</p><p>There is not one most favored solution though and we all have various
experiences with these techniques.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="decision">Decision<a class="hash-link" href="#decision" title="見出しへの直接リンク">​</a></h2><p>Effectful components of the Hydra node (our code) will be defined using the <em>Handle pattern</em>.</p><p>There might be other techniques in use because of libraries used etc.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="consequences">Consequences<a class="hash-link" href="#consequences" title="見出しへの直接リンク">​</a></h2><p>For example, the network component is defined as:</p><div class="codeBlockContainer_I0IT language-hs theme-code-block"><div class="codeBlockContent_wNvx hs"><pre tabindex="0" class="prism-code language-hs codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">newtype Network m = Network</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  { broadcast :: MonadThrow m =&gt; HydraMessage -&gt; m ()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span></code></pre><button type="button" aria-label="クリップボードにコードをコピー" class="copyButton_wuS7 clean-btn">コピー</button></div></div><p>There might be multiple <code>createNetwork :: m (Network m)</code> functions</p>]]></content>
        <category label="Accepted" term="Accepted"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[5. Use io-classes
]]></title>
        <id>5</id>
        <link href="https://input-output-hk.github.io/head-protocol/ja/adr/5"/>
        <updated>2021-06-09T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Status]]></summary>
        <content type="html"><![CDATA[<h2 class="anchor anchorWithStickyNavbar_mojV" id="status">Status<a class="hash-link" href="#status" title="見出しへの直接リンク">​</a></h2><p>Accepted</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="context">Context<a class="hash-link" href="#context" title="見出しへの直接リンク">​</a></h2><p>Although we try to contain the use of IO at the outskirt of the Hydra node using <a href="/head-protocol/ja/adr/4">Handle pattern</a> and <a href="/head-protocol/ja/adr/2">Reactive core</a>, low-level effects are still needed in various places, notably to define concurrently executing actions, and thus need to be tested</p><p>Testing asynchronous and concurrent code is notoriously painful</p><p>The ouroboros consensus test suite and <a href="https://github.com/input-output-hk/hydra-sim" target="_blank" rel="noopener noreferrer">hydra-sim</a> simulation have demonstrated the effectiveness of abstracting concurrent primitives through the use of typeclasses (MTL-style pattern) and being able to run these as pure code, harvesting and analysing produced execution traces.</p><p>There are other such libraries, e.g. <a href="https://hackage.haskell.org/package/concurrency" target="_blank" rel="noopener noreferrer">concurrency</a> and <a href="https://hackage.haskell.org/package/dejafu" target="_blank" rel="noopener noreferrer">dejafu</a>, as well as the venerable <a href="https://hackage.haskell.org/package/exceptions" target="_blank" rel="noopener noreferrer">exceptions</a> (for abstracting exception throwing).</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="decision">Decision<a class="hash-link" href="#decision" title="見出しへの直接リンク">​</a></h2><p>For all IO effects covered by the library, use functions from typeclasses exposed by <a href="https://github.com/input-output-hk/ouroboros-network/tree/e338f2cf8e1078fbda9555dd2b169c6737ef6774/io-classes" target="_blank" rel="noopener noreferrer">io-classes</a>. As of this writing, this covers:</p><ul><li>All STM operations through <code>MonadSTM</code></li><li>Time and timers through <code>MonadTime</code> and <code>MonadTimer</code></li><li>Concurrency through <code>MonadAsync</code>, <code>MonadFork</code></li><li>Exceptions through <code>MonadThrow</code>, <code>MonadCatch</code> and <code>MonadMask</code></li></ul><h2 class="anchor anchorWithStickyNavbar_mojV" id="consequences">Consequences<a class="hash-link" href="#consequences" title="見出しへの直接リンク">​</a></h2><p>We can use <code>io-sim</code> to evaluate IO-ish functions easily</p><p>Instantiation to concrete IO is pushed at the outermost layer, eg. in the <code>Main</code> or tests.</p><p>As some of these functions and typeclasses clash with the
<a href="https://github.com/input-output-hk/cardano-prelude" target="_blank" rel="noopener noreferrer">cardano-prelude</a> we might
want to define a custom prelude (candidate for another ADR)</p>]]></content>
        <category label="Accepted" term="Accepted"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[6. Network Broadcasts all messages
]]></title>
        <id>6</id>
        <link href="https://input-output-hk.github.io/head-protocol/ja/adr/6"/>
        <updated>2021-06-10T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Status]]></summary>
        <content type="html"><![CDATA[<h2 class="anchor anchorWithStickyNavbar_mojV" id="status">Status<a class="hash-link" href="#status" title="見出しへの直接リンク">​</a></h2><p>Accepted</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="context">Context<a class="hash-link" href="#context" title="見出しへの直接リンク">​</a></h2><p>The simplified Head protocol in the <a href="https://iohk.io/en/research/library/papers/hydrafast-isomorphic-state-channels/" target="_blank" rel="noopener noreferrer">Hydra
paper</a>
requires <em>unicast</em> and <em>multicast</em> messaging between participants. However, this
can be simplified to only <em>multicast</em> by also sending <code>AckTx</code> messages to all
participants and removing the necessity for <code>ConfTx</code>.</p><p>There is already a battle-tested implementation for <em>broadcasting</em> messages over
networks with any kind of topology (mesh), namely the
<a href="https://github.com/input-output-hk/ouroboros-network/tree/master/ouroboros-network/src/Ouroboros/Network/TxSubmission" target="_blank" rel="noopener noreferrer">TxSubmission</a>
protocol of <code>ouroroboros-network</code>.</p><p>If the network connects only to interested peers, <em>broadcast</em> is essentially the
<em>multicast</em> required by the protocol. If this is not the case, some addressing
scheme is required and <em>broadcast</em> would be a waste of resources.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="decision">Decision<a class="hash-link" href="#decision" title="見出しへの直接リンク">​</a></h2><ul><li>All messages emitted by a Hydra node through the Network component are <em>broadcasted</em> to <em>all</em> nodes in the network</li><li>This implies the emitter shall itself receive the message</li></ul><h2 class="anchor anchorWithStickyNavbar_mojV" id="consequences">Consequences<a class="hash-link" href="#consequences" title="見出しへの直接リンク">​</a></h2><ul><li>The network layer is responsible for ensuring sent messages effectively
reaches all nodes in the network. How this is achieved is left as an
implementation detail, i.e. whether it uses relaying or not.</li><li>We need to make sure all Head participants are connected to the same network.</li></ul>]]></content>
        <category label="Accepted" term="Accepted"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[7. Use with-pattern based component interfaces
]]></title>
        <id>7</id>
        <link href="https://input-output-hk.github.io/head-protocol/ja/adr/7"/>
        <updated>2021-06-11T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Status]]></summary>
        <content type="html"><![CDATA[<h2 class="anchor anchorWithStickyNavbar_mojV" id="status">Status<a class="hash-link" href="#status" title="見出しへの直接リンク">​</a></h2><p>Accepted</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="context">Context<a class="hash-link" href="#context" title="見出しへの直接リンク">​</a></h2><p>The <em>with pattern</em> or <em>bracket pattern</em> is a functional programming idiom, a
particular instance of <em>Continuation-Passing Style</em>, whereby one component that
controls some resource that is consumed by another component of the system, is
created via a function that takes as argument a function consuming the resource,
instead of returning it. This pattern allows safe reclaiming of resources when
the "wrapped" action terminates, whether normally or unexpectedly.</p><p>TODO "Tying the knot"</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="decision">Decision<a class="hash-link" href="#decision" title="見出しへの直接リンク">​</a></h2><p>We use this pattern to provide interfaces to all <em>active components</em>, which
exchange messages with other components of the system. A prototypical signature
of such a component could be:</p><div class="codeBlockContainer_I0IT language-hs theme-code-block"><div class="codeBlockContent_wNvx hs"><pre tabindex="0" class="prism-code language-hs codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">type Component m = inmsg -&gt; m ()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">type Callback m = outmsg -&gt; m ()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">withXXX :: Callback m -&gt; (Component m -&gt; m a) -&gt; m a</span><br></span></code></pre><button type="button" aria-label="クリップボードにコードをコピー" class="copyButton_wuS7 clean-btn">コピー</button></div></div><p>Note that <code>withXXX</code> can also allocate resources in order to provide <code>Component</code>
or use the <code>Callback</code>, e.g. fork threads which invoke <code>Callback</code>, but also make
sure they are cleaned up.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="consequences">Consequences<a class="hash-link" href="#consequences" title="見出しへの直接リンク">​</a></h2><p>Components can be layered on top of another to provide additional behavior given the same interface. This also similar to "decorating" in the object-orientation world.</p><p>If the <code>Component</code> is agnostic about the messages it consumes/produces, it can be defined as a <a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/Data-Functor-Contravariant.html" target="_blank" rel="noopener noreferrer"><code>Contravariant</code> functor</a> and the <code>Callback</code> part as a (covariant) <code>Functor</code>. This makes it possible to use <code>map</code> and <code>contramap</code> operations to transform messages.</p>]]></content>
        <category label="Accepted" term="Accepted"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[8. Custom Prelude
]]></title>
        <id>8</id>
        <link href="https://input-output-hk.github.io/head-protocol/ja/adr/8"/>
        <updated>2021-06-18T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Status]]></summary>
        <content type="html"><![CDATA[<h2 class="anchor anchorWithStickyNavbar_mojV" id="status">Status<a class="hash-link" href="#status" title="見出しへの直接リンク">​</a></h2><p>Accepted</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="context">Context<a class="hash-link" href="#context" title="見出しへの直接リンク">​</a></h2><p>In a Haskell project, we often get to use and re-use the same libraries and functions. Haskell comes with a default <code>Prelude</code> package with the <code>base</code> library, which provides a good and sensible starting point. However, the base <code>Prelude</code> also comes with a few quirks:</p><ul><li>Many commonly used functions or constructors are not exported by default (e.g. <code>bracket</code>, <code>foldM</code>, <code>first</code>, <code>lift</code>, <code>forM</code>, <code>when</code>, <code>SomeException</code>, <code>Set</code>, <code>&amp;</code> ...etc).</li><li>Many functions in the base Prelude are partial, like <code>head</code> or <code>read</code>. </li><li>Many functions simply happens in plain <code>IO</code>, whereas applications usually try to push IO to the boundary as much as possible (for example, using mtl-style class constraints).</li><li>The interface for I/O operations in the base Prelude is <code>String</code>, which comes with quite major performance hit and often forces to convert back and forth to <code>Text</code> or <code>ByteString</code> equivalents.</li></ul><p>All-in-all, while it <em>does the job</em>, the base <code>Prelude</code> may not necessarily be the most <em>convenient</em> prelude for an active project development. </p><h2 class="anchor anchorWithStickyNavbar_mojV" id="decision">Decision<a class="hash-link" href="#decision" title="見出しへの直接リンク">​</a></h2><p>We'll use a custom prelude to help us get more productive and more importantly, to reduce the daily friction of our interactions with the base prelude. While <a href="https://hackage.haskell.org/package/relude" target="_blank" rel="noopener noreferrer"><code>relude</code></a> makes for a good candidate, we still chose to re-wrap it in a custom <code>Hydra.Prelude</code> module to grant us the ability to add or remove a few things specifics to Hydra and Cardano in general. In particular, we will hide from <code>relude</code> all the re-exports of the <a href="https://hackage.haskell.org/package/stm" target="_blank" rel="noopener noreferrer"><code>stm</code></a> library in favor of <a href="https://github.com/input-output-hk/ouroboros-network/tree/e338f2cf8e1078fbda9555dd2b169c6737ef6774/io-classes" target="_blank" rel="noopener noreferrer"><code>io-classes</code></a> which we already use pervasively and which provides (among other things) most of the same capabilities.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="consequences">Consequences<a class="hash-link" href="#consequences" title="見出しへの直接リンク">​</a></h2><ul><li>Remove uses of 'cardano-prelude' in favor of a new 'hydra-prelude' module.</li><li>Cleaning up of imports from existing file modules.</li><li>Happier feeling day after day from using a developer-friendly prelude.</li><li>Stop loosing time in often re-importing the same functions over and over. </li><li>Have an explicit point for discouraging / blessing usage of one or the other function, as well as documenting such decisions</li></ul>]]></content>
        <category label="Accepted" term="Accepted"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[9. Simplify Logging
]]></title>
        <id>9</id>
        <link href="https://input-output-hk.github.io/head-protocol/ja/adr/9"/>
        <updated>2021-08-19T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Status]]></summary>
        <content type="html"><![CDATA[<h2 class="anchor anchorWithStickyNavbar_mojV" id="status">Status<a class="hash-link" href="#status" title="見出しへの直接リンク">​</a></h2><p>Proposed</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="context">Context<a class="hash-link" href="#context" title="見出しへの直接リンク">​</a></h2><ul><li>Logs are critical to provide <em>observability</em> to Hydra nodes' operators</li><li>Providing the needed components and tools to be able to configure logging and monitoring to each operator's liking should not be the responibility of the Hydra node, and requires complex machinery that will need to be maintained and evolved</li><li>When a problem occurs in production, if the process is not verbose enough it can be very hard to analyse the problem<ul><li>Enabling dynamic changes of verbosity in logs is both complex to implement and comes too late</li><li>Deciding in the code on what's the right "severity" for a log entry leads to dropping important information on <em>how</em> some error occured</li></ul></li></ul><h2 class="anchor anchorWithStickyNavbar_mojV" id="decision">Decision<a class="hash-link" href="#decision" title="見出しへの直接リンク">​</a></h2><p><em>Therefore</em></p><p>Hydra node provides a very simplified logging mechanism whereby:</p><ul><li>All logs are emitted as JSON-encoded structures providing some metadata (timestamp, threadId) around well-defined data</li><li>Each <em>log entry</em> is written to the <code>hydra-node</code> process' <em>stdout</em> port, one line per entry</li><li>The definition of the logged items is considered to be part of the public AγPI of the Hydra node</li></ul><p><strong>Note</strong>: Proper redaction of sensitive information contained in log entries should still be handled in the code.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="consequences">Consequences<a class="hash-link" href="#consequences" title="見出しへの直接リンク">​</a></h2><ul><li>The schema of the logged items should be properly documented in a JSON schema, just like we do for client side API</li><li>It is the responsibility of the node operator to consume the logs and process them</li></ul>]]></content>
        <category label="Accepted" term="Accepted"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[10. Use Direct Connection to `cardano-node`
]]></title>
        <id>10</id>
        <link href="https://input-output-hk.github.io/head-protocol/ja/adr/10"/>
        <updated>2021-10-23T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Status]]></summary>
        <content type="html"><![CDATA[<h2 class="anchor anchorWithStickyNavbar_mojV" id="status">Status<a class="hash-link" href="#status" title="見出しへの直接リンク">​</a></h2><p>Accepted</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="context">Context<a class="hash-link" href="#context" title="見出しへの直接リンク">​</a></h2><ul><li>On-Chain Validation is a critical part of the Hydra protocol, it requires both the ability to <em>submit</em> transactions to the <em>Layer 1</em> chain advancing the state of a Head, and <em>observing</em> those transactions as the <a href="https://github.com/input-output-hk/plutus" target="_blank" rel="noopener noreferrer">Plutus</a> contracts are validated</li><li>The <a href="https://github.com/input-output-hk/plutus-apps" target="_blank" rel="noopener noreferrer">Plutus Application Framework</a> is expected to provide the necessary machinery to allow "Smart Contracts" applications to interact with the chain but it's still under active development and not ready for deployment on-chain</li><li>We want to gather feedback as early as possible and deliver a fully functional Hydra Head node for early adopters to test on a "real" chain (testnet)</li><li>Our experiment connecting directly to a Cardano node has been conclusive. We can:<ul><li>Connect to a node using local protocols,</li><li>Build and submit Head transactions triggering smart contracts validation, and</li><li>Observe transactions using chain-sync protocol.</li></ul></li></ul><h2 class="anchor anchorWithStickyNavbar_mojV" id="decision">Decision<a class="hash-link" href="#decision" title="見出しへの直接リンク">​</a></h2><p><em>Therefore</em></p><p>For the time being, until <em>Plutus Application Framework</em> is released, we will implement on-chain interaction of Hydra nodes <em>directly</em>, connecting to a Cardano node through a <em>local socket</em>.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="consequences">Consequences<a class="hash-link" href="#consequences" title="見出しへの直接リンク">​</a></h2><ul><li>Limit Hydra dependencies to <a href="https://github.com/input-output-hk/plutus" target="_blank" rel="noopener noreferrer">plutus</a> repository</li><li>Remove all PAB-related code as well as off-chain <code>Contract</code>s code and related dependencies</li><li>An updated architecture diagram:</li></ul><p><img loading="lazy" src="/head-protocol/ja/assets/images/hydra-architecture-direct-f8764611c3938f0155b30eba9f6339f2.jpg" width="3420" height="1827"></p>]]></content>
        <category label="Accepted" term="Accepted"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[11. Use cardano-api
]]></title>
        <id>11</id>
        <link href="https://input-output-hk.github.io/head-protocol/ja/adr/11"/>
        <updated>2021-11-18T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Status]]></summary>
        <content type="html"><![CDATA[<h2 class="anchor anchorWithStickyNavbar_mojV" id="status">Status<a class="hash-link" href="#status" title="見出しへの直接リンク">​</a></h2><p>Accepted</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="context">Context<a class="hash-link" href="#context" title="見出しへの直接リンク">​</a></h2><ul><li>To implement Hydra Head's ledger we have been working with the <a href="https://github.com/input-output-hk/cardano-ledger-specs" target="_blank" rel="noopener noreferrer">ledger-specs</a> packages which provide a low-level interface to work with transactions and ledgers<ul><li>We also use a lightly wrapped ledger-specs API as our interface for Off-chain transaction submission. This introduced some boilerplate in order to align with cardano-api and provide JSON serialisation.</li></ul></li><li>In our initial experiments <a href="/head-protocol/ja/adr/10">connecting directly</a> to a cardano node we have also been using the ledger API for building transactions for want of some scripts-related features in the cardano-api</li><li>cardano-api is expected to be the supported entrypoint for clients to interact with Cardano chain while ledger-specs is reserved for internal use and direct interactions with ledgers</li><li>cardano-api now provides all the features we need to run our on-chain validators</li></ul><h2 class="anchor anchorWithStickyNavbar_mojV" id="decision">Decision<a class="hash-link" href="#decision" title="見出しへの直接リンク">​</a></h2><p><em>Therefore</em></p><ul><li>Use cardano-api types and functions instead of ledger-specs in <code>Hydra.Chain.Direct</code> component</li><li>Use cardano-api types instead of custom ones in <code>Hydra.Ledger.Cardano</code> component</li></ul><h2 class="anchor anchorWithStickyNavbar_mojV" id="consequences">Consequences<a class="hash-link" href="#consequences" title="見出しへの直接リンク">​</a></h2><ul><li>Removes the boilerplate in <code>Hydra.Ledger.Cardano</code> required to map cardano-api types sent by clients to builtin and ledger-specs types</li><li>Simplifies the  <code>Hydra.Chain.Direct</code> component:<ul><li>Replaces custom transaction building in <code>Tx</code></li><li>Replaces custom transaction fees calculation and balancing in <code>Wallet</code></li><li>Replace low-level connection establishment using cardano-api functions connecting to the node (keeping the chain sync subscription)</li></ul></li></ul>]]></content>
        <category label="Accepted" term="Accepted"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[12. Top-down Test-driven Design
]]></title>
        <id>12</id>
        <link href="https://input-output-hk.github.io/head-protocol/ja/adr/12"/>
        <updated>2021-11-25T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Status]]></summary>
        <content type="html"><![CDATA[<h2 class="anchor anchorWithStickyNavbar_mojV" id="status">Status<a class="hash-link" href="#status" title="見出しへの直接リンク">​</a></h2><p>Accepted</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="context">Context<a class="hash-link" href="#context" title="見出しへの直接リンク">​</a></h2><ul><li><a href="https://en.wikipedia.org/wiki/Test-driven_development" target="_blank" rel="noopener noreferrer">Test-Driven Development</a> or <em>Test-Driven Design</em> is a technique that helps team promotes simple and loosely coupled design, reduces the amount of code written, increases confidence in delivered software by providing a high level of code coverage by regression tests, and improves development speed through shorter feedback loop</li><li>While initially focused on <em>unit tests</em>, TDD has evolved over time to include higher-level tests like <a href="https://en.wikipedia.org/wiki/Behavior-driven_development" target="_blank" rel="noopener noreferrer">Behaviour Driven Development</a> or <a href="https://en.wikipedia.org/wiki/Specification_by_example" target="_blank" rel="noopener noreferrer">Specification by Example</a>, leading to comprehensive strategies like the <a href="http://tpierrain.blogspot.com/2021/03/outside-in-diamond-tdd-1-style-made.html" target="_blank" rel="noopener noreferrer">Outside-In Diamond TDD</a></li><li>Being a foundational part of scalable applications based on Cardano blockchain, Hydra Head needs to be released early, often, and with high assurance in order to benefit from early adopters' feedback</li></ul><h2 class="anchor anchorWithStickyNavbar_mojV" id="decision">Decision<a class="hash-link" href="#decision" title="見出しへの直接リンク">​</a></h2><p><em>Therefore</em></p><p>We start as early as possible with <em>End-to-End</em> tests, gradually making them more complex as we develop the various components but starting with something simple (like a system-level but dummy chain and hydra network).</p><p>We flesh out other integration tests as needed, when we refine the technological stack used for the various bits and pieces.</p><p>We do most of our work in the <em>Executable Specifications</em> layer while we are developing the core domain functions, eg. the Head protocol. The rationale being this is the level at which we can test the most complex behaviours in the fastest and safest possible way as we everything runs without external dependencies or can even run as pure code using io-sim.</p><p>We tactically drop to <em>Unit tests</em> level when dealing with the protocol's "fine prints".</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="consequences">Consequences<a class="hash-link" href="#consequences" title="見出しへの直接リンク">​</a></h2><ul><li>Development of each "feature", whether new or change to existing one, should start with a test defined at the highest level possible, but no higher</li><li>A detailed presentation of the various testing layers is available in the <a href="https://github.com/input-output-hk/hydra-poc/wiki/Testing-Strategy" target="_blank" rel="noopener noreferrer">wiki</a></li></ul>]]></content>
        <category label="Accepted" term="Accepted"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[13. Plutus Contracts Testing Strategy
]]></title>
        <id>13</id>
        <link href="https://input-output-hk.github.io/head-protocol/ja/adr/13"/>
        <updated>2022-01-19T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Status]]></summary>
        <content type="html"><![CDATA[<h2 class="anchor anchorWithStickyNavbar_mojV" id="status">Status<a class="hash-link" href="#status" title="見出しへの直接リンク">​</a></h2><p>Accepted</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="context">Context<a class="hash-link" href="#context" title="見出しへの直接リンク">​</a></h2><ul><li>We are implementing our custom (<a href="/head-protocol/ja/adr/10">Direct</a>) interaction w/ Cardano blockchain and not using the PAB nor the <code>Contract</code> monad to define off-chain contract code</li><li>This implies we cannot use the <a href="https://github.com/input-output-hk/plutus-apps/blob/main/plutus-contract/src/Plutus/Contract/Test.hs" target="_blank" rel="noopener noreferrer">official</a> testing framework for Contracts which relies on <code>Contract</code> monad and emulator traces nor the <a href="https://plutus-apps.readthedocs.io/en/latest/plutus/tutorials/contract-testing.html" target="_blank" rel="noopener noreferrer">QuickCheck based framework</a></li><li>We want to follow our <a href="/head-protocol/ja/adr/12">Test-Driven Development</a> approach for contracts as this is a critical part of Hydra</li><li>On-Chain Validators need not only to be correct and functional, but also secure and hardened against malicious parties</li></ul><h2 class="anchor anchorWithStickyNavbar_mojV" id="decision">Decision<a class="hash-link" href="#decision" title="見出しへの直接リンク">​</a></h2><p><em>Therefore</em></p><ul><li>We test-drive single contracts code using <em>Mutation-Based Property Testing</em></li><li>Contracts are tested through the construction of actual <em>transactions</em> and running phase-2 ledger validation process</li><li>We start from a "healthy" transaction, that's expected to be correct and stay so</li><li>Contract code is initially <code>const True</code> function that validates any transaction</li><li>We flesh the contract's code piecemeal through the introduction of <em>Mutations</em> that turn a healthy transaction into an expectedly invalid one</li><li>We gradually build a set of combinators and generators that make it easier to mutate arbitrarily transactions, and combine those mutations</li></ul><h2 class="anchor anchorWithStickyNavbar_mojV" id="consequences">Consequences<a class="hash-link" href="#consequences" title="見出しへの直接リンク">​</a></h2><ul><li>We make the contracts' <em>Threat model</em>  explicit through the tests we write, which should help future auditors' work</li><li>We'll need an additional layer of tests to exercise the Hydra OCV State Machine through <em>sequence of transactions</em>. This could be implemented using <a href="https://github.com/input-output-hk/plutus-apps/tree/main/quickcheck-dynamic" target="_blank" rel="noopener noreferrer">quickcheck-dynamic</a> library, or other tools that are currently being developed by the Cardano community</li></ul>]]></content>
        <category label="Accepted" term="Accepted"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[14. Token usage in Hydra Scripts
]]></title>
        <id>14</id>
        <link href="https://input-output-hk.github.io/head-protocol/ja/adr/14"/>
        <updated>2022-02-14T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Status]]></summary>
        <content type="html"><![CDATA[<h2 class="anchor anchorWithStickyNavbar_mojV" id="status">Status<a class="hash-link" href="#status" title="見出しへの直接リンク">​</a></h2><p>Accepted</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="context">Context<a class="hash-link" href="#context" title="見出しへの直接リンク">​</a></h2><ul><li>The Hydra on-chain-verification scripts are used to validate Hydra protocol transactions and ensure they are lawful.</li><li>At least these three properties need to be enforced:<ul><li>Authentication: ensure that only Head participants can, for example, <code>abort</code> a Head</li><li>Contract continuity: ensure that a Head was <code>init</code>ialized before it can be opened by a <code>collectCom</code> tx.</li><li>Completeness: ensure that all Head participants had chance to <code>commit</code> funds to a Head.</li></ul></li><li>The Hydra Head paper introduces <strong>participation tokens (PT)</strong> and a <strong>state thread token (ST)</strong> for that matter.</li><li>Such tokens (a.k.a native assets) are identified by the <code>CurrencySymbol</code>, that is the hash of their <code>MintingPolicyScript</code> (a.k.a <code>PolicyID</code> in the ledger), and a <code>ByteString</code>, the socalled <code>TokenName</code> (a.k.a as <code>AssetName</code> in the ledger, see <a href="https://hydra.iohk.io/job/Cardano/cardano-ledger-specs/specs.shelley-ma/latest/download-by-type/doc-pdf/shelley-ma#subsection.3.2" target="_blank" rel="noopener noreferrer">shelley-ma ledger spec</a>)</li><li>There can be multiple Hydra Heads on a network and a <code>hydra-node</code> need to distinguish individual Head instances or even (later) keep track of multiple Heads. Concretely, this means that we need to infer a Head identifier (<code>HeadId</code>) from observing each of the Hydra protocol transactions. </li></ul><h2 class="anchor anchorWithStickyNavbar_mojV" id="decision">Decision<a class="hash-link" href="#decision" title="見出しへの直接リンク">​</a></h2><ul><li>We solve both challenges by defining that ST and PTs <strong>shall use the same</strong> <code>MintingPolicyScript</code> and thus have same <code>CurrencySymbol</code></li><li>The <code>MintingPolicyScript</code> shall be parameterized by <code>TxOutRef</code> to yield a unique <code>CurrencySymbol</code> per Head
(similar to the <a href="https://github.com/input-output-hk/plutus/tree/1efbb276ef1a10ca6961d0fd32e6141e9798bd11/plutus-use-cases/src/Plutus/Contracts/Currency.hs" target="_blank" rel="noopener noreferrer"><code>OneShotCurrency</code></a> example)</li><li>ST and one PT per participant are minted in the <code>initTx</code></li><li>The <code>TokenName</code> of the ST can be any well-known <code>ByteString</code>, e.g. <code>"HydraHeadV1"</code></li><li>The <code>TokenName</code> of the PTs needs to be the <code>PubKeyHash</code> of the respective participant</li></ul><h2 class="anchor anchorWithStickyNavbar_mojV" id="consequences">Consequences<a class="hash-link" href="#consequences" title="見出しへの直接リンク">​</a></h2><ul><li><p>Heads can be identified by looking for the <code>ST</code> in <code>init</code>, <code>collectCom</code>, <code>close</code>, <code>contest</code> or <code>fanout</code> transactions, or the <code>PT</code> in <code>commit</code> transactions. In both cases, the <code>CurrencySymbol == HeadId</code></p></li><li><p>Our scripts become simpler as we only need to check that ST/PT are paid forward, instead of needing to check datums</p></li><li><p>The datum produced by <code>commit</code> txs (and consumed by <code>collectCom</code>) is <code>Just SerializedTxOut</code>, which is simpler than also keeping the participant which committed in the datum (compare to full life-cycle of <a href="https://github.com/input-output-hk/hydra-poc/tree/0.3.0/docs/images/on-chain-full.jpg" target="_blank" rel="noopener noreferrer">0.3.0</a>).</p></li><li><p>The <code>v_head</code> script validator does not need to be parameterized, which makes discovering new Heads (and also tracking them for metrics) easier as the address to watch for is common to all Heads (of the same <code>v_head</code> version).</p></li><li><p>The <code>v_head</code> script (path) for the abort life-cycle can be implemented already much safer by checking that all PTs are burned on the <code>abort</code> transaction (counting inputs in abort life-cycle of <a href="https://github.com/input-output-hk/hydra-poc/tree/0.3.0/docs/images/on-chain-abort.jpg" target="_blank" rel="noopener noreferrer">0.3.0</a>).</p></li><li><p>Updated diagrams for the <a target="_blank" href="/head-protocol/ja/assets/files/on-chain-full-eea3dda97376810a7bfac1848a11a84a.jpg">full</a> and <a target="_blank" href="/head-protocol/ja/assets/files/on-chain-abort-c3483946d3116662c5cabfd67e3dde4e.jpg">abort</a> on-chain life-cycles of a Hydra Head.</p></li></ul><h2 class="anchor anchorWithStickyNavbar_mojV" id="follow-up-questions">Follow-up questions<a class="hash-link" href="#follow-up-questions" title="見出しへの直接リンク">​</a></h2><ul><li>What value does the <code>ST</code> actually add? We could always look for the <code>PT</code> to identify a Head and contract continuity would already be achieved by the <code>PT</code>s!</li></ul>]]></content>
        <category label="Accepted" term="Accepted"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[15. Configuration Through an Admin API
]]></title>
        <id>15</id>
        <link href="https://input-output-hk.github.io/head-protocol/ja/adr/15"/>
        <updated>2022-03-17T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Status]]></summary>
        <content type="html"><![CDATA[<h2 class="anchor anchorWithStickyNavbar_mojV" id="status">Status<a class="hash-link" href="#status" title="見出しへの直接リンク">​</a></h2><p>Draft</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="context">Context<a class="hash-link" href="#context" title="見出しへの直接リンク">​</a></h2><ul><li>Hydra-node currently requires a whole slew of command-line arguments to configure properly its networking layer: <code>--peer</code> to connect to each peer, <code>--cardano-verification-key</code> and <code>--hydra-verification-key</code> to identify the peer on the L1 and L2 respectively.</li><li>This poses significant challenges for operating a <em>cluster</em> of Hydra nodes as one needs to know beforehand everything about the cluster, then pass a large number of arguments to some program or docker-compose file, before any node can be started<ul><li>This is a pain that's been felt first-hand for benchmarking and testing purpose</li></ul></li><li>Having static network configuration is probably not sustainable in the long run, even if we don't add any fancy multihead capabilities to the node, as it would make it significantly harder to have automated creation of Heads.</li><li>There's been an <a href="https://github.com/input-output-hk/hydra-poc/pull/222" target="_blank" rel="noopener noreferrer">attempt</a> at providing a file-based network configuration but this was deemed unconvincing</li><li><a href="https://eprint.iacr.org/2020/299.pdf" target="_blank" rel="noopener noreferrer">Hydra paper (sec. 4, p. 13)</a> explicitly assumes the existence of a <em>setup</em> phase<ul><li>This <em>setup</em> is currently left aside, e.g. exchange of keys for setting up multisig and identifying peers. The <a href="https://github.com/input-output-hk/hydra-poc/blob/abailly-iohk/admin-api-adr/hydra-node/exe/hydra-node/Main.hs#L41" target="_blank" rel="noopener noreferrer">hydra-node</a> executable is statically configured and those things are assumed to be known beforehand</li></ul></li></ul><h2 class="anchor anchorWithStickyNavbar_mojV" id="decision">Decision<a class="hash-link" href="#decision" title="見出しへの直接リンク">​</a></h2><ul><li>Hydra-node exposes an <em>Administrative API</em> to enable configuration of the Hydra network using "standard" tools<ul><li>API is exposed as a set of HTTP endpoints on some port, consuming and producing JSON data,</li><li>It is documented as part of the User's Guide for Hydra Head</li></ul></li><li>This API provides <em>commands</em> and <em>queries</em> to:<ul><li>Add/remove <em>peers</em> providing their address and keys,</li><li>List currently known peers and their connectivity status,</li><li>Start/stop/reset the Hydra network</li></ul></li><li>This API is implemented by a <em>new component</em> accessible through a network port separate from current <em>Client API</em>, that <em>configures</em> the <code>Network</code> component</li></ul><p>The following picture sketches the proposed architectural change:</p><p><img loading="lazy" alt="Architecture change" src="/head-protocol/ja/assets/images/0015-architecture-change-18873d5f6fa6f8237431a6cfa83a03e3.jpg" width="5351" height="2989"></p><h2 class="anchor anchorWithStickyNavbar_mojV" id="qa">Q&amp;A<a class="hash-link" href="#qa" title="見出しへの直接リンク">​</a></h2><ul><li><em>Why a REST interface?</em><ul><li>This API is an interface over a specific <em>resource</em> controlled by the Hydra node, namely its knowledge of other peers with which new <em>Head_s can be opened. As such a proper REST interface (_not</em> RPC-in-disguise) seems to make sense here, rather than stream/event-based <a href="/head-protocol/ja/adr/3">duplex communication channels</a></li><li>We can easily extend such an API with WebSockets to provide notifications (e.g. peers connectivity, setup events...)</li></ul></li><li><em>Why a separate component?</em><ul><li>We could imagine extending the existing <a href="https://github.com/input-output-hk/hydra-poc/blob/9129c7c013fe2cdc77db048a54981e1ace0843b8/hydra-node/src/Hydra/API/Server.hs" target="_blank" rel="noopener noreferrer">APIServer</a> interface with new messages related to this network configuration, however this seems to conflate different responsibilities in a single place: Configuring and managing the Hydra node itself, and configuring, managing, and interacting with the Head itself</li><li>"Physical" separation of endpoints makes it easier to secure a very sensitive part of the node, namely its administration, e.g by ensuring this can only be accessed through a specific network interface, without relying on application level authentication mechanisms</li></ul></li></ul><h2 class="anchor anchorWithStickyNavbar_mojV" id="consequences">Consequences<a class="hash-link" href="#consequences" title="見出しへの直接リンク">​</a></h2><ul><li>It's easy to deploy Hydra nodes with some standard configuration, then dynamically configure them, thus reducing the hassle of defining and configuring the Hydra network</li><li>It makes it possible to <em>reconfigure</em> a Hydra node with different peers</li><li>The <em>Client API</em> should reflect the state of the network and disable <code>Init</code>ing a head if the network layer is not started<ul><li>In the long run, it should also have its scope reduced to represent only the possible interactions with a <em>Head</em>, moving things related to network connectivity and setup to the Admin API</li><li>In a <em>Managed Head</em> scenario it would even make sense to have another layer of separation between the API to manage the life-cycle of the Head and the API to make transactions within the Head</li></ul></li><li>Operational tools could be built easily on top of the API, for command-line or Web-based configuration</li></ul>]]></content>
        <category label="Draft" term="Draft"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[16. Keep Rejected ADRs
]]></title>
        <id>16</id>
        <link href="https://input-output-hk.github.io/head-protocol/ja/adr/16"/>
        <updated>2022-03-23T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Status]]></summary>
        <content type="html"><![CDATA[<h2 class="anchor anchorWithStickyNavbar_mojV" id="status">Status<a class="hash-link" href="#status" title="見出しへの直接リンク">​</a></h2><p>Accepted</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="context">Context<a class="hash-link" href="#context" title="見出しへの直接リンク">​</a></h2><p>We have started using <em>Architecture Decision Records</em> as our primary way to document the most important design decisions we take while developing Hydra Node, and this has proved effective in fostering fruitful discussions about major architecture changes.</p><p>During the course of this project, we have sometimes had debates on various topics leading to rejection of <a href="https://github.com/input-output-hk/hydra-poc/pull/230" target="_blank" rel="noopener noreferrer">some ADRs</a>. It could be the case that  a previously rejected proposal turns out to be interesting, either because the context and situation have changed enough to reevaluate a proposal, or as background for some new proposal.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="decision">Decision<a class="hash-link" href="#decision" title="見出しへの直接リンク">​</a></h2><p><em>therefore</em></p><ul><li>We will keep rejected <em>Architecture Decision Records</em> alongside accepted and draft ones, in the same location and format</li><li>Rejected ADRs <em>must</em> have tag <code>[Rejected]</code> set</li></ul><h2 class="anchor anchorWithStickyNavbar_mojV" id="consequences">Consequences<a class="hash-link" href="#consequences" title="見出しへの直接リンク">​</a></h2><p>Once attributed a <em>serial number</em> an ADR keeps it "forever", whether it's rejected or accepted</p>]]></content>
        <category label="Accepted" term="Accepted"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[17. Use UDP protocol for Hydra networking
]]></title>
        <id>17</id>
        <link href="https://input-output-hk.github.io/head-protocol/ja/adr/17"/>
        <updated>2022-03-28T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Status]]></summary>
        <content type="html"><![CDATA[<h2 class="anchor anchorWithStickyNavbar_mojV" id="status">Status<a class="hash-link" href="#status" title="見出しへの直接リンク">​</a></h2><p>Draft</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="context">Context<a class="hash-link" href="#context" title="見出しへの直接リンク">​</a></h2><p>Current Hydra networking layer is based on <a href="https://github.com/input-output-hk/ouroboros-network/tree/master/ouroboros-network-framework" target="_blank" rel="noopener noreferrer">Ouroboros network framework</a> networking stack which, among other features, provides:</p><ol><li>An abstraction of stream-based duplex communication channels called a <a href="https://github.com/input-output-hk/ouroboros-network/blob/6c15a8093bac34091ad96af2b8b0d1f7fe54b732/ouroboros-network-framework/src/Ouroboros/Network/Snocket.hs" target="_blank" rel="noopener noreferrer">Snocket</a>,</li><li>A Multiplexing connection manager that manages a set of equivalent peers, maintains connectivity, and ensures diffusion of messages to/from all peers,</li><li>Typed protocols for expressing the logic of message exchanges as a form of <em>state machine</em>.</li></ol><p>While it's been working mostly fine so far, the abstractions and facilities provided by this network layer are not well suited for Hydra Head networking. Some of the questions and shortcomings are discussed in a document on <a href="/head-protocol/ja/core-concepts/networking">Networking Requirements</a>, and as the Hydra Head matures it seems time is ripe for overhauling current network implementation to better suite current and future Hydra Head networks needs.</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="decision">Decision<a class="hash-link" href="#decision" title="見出しへの直接リンク">​</a></h2><ul><li>Hydra Head nodes communicate by sending messages to other nodes using <a href="https://en.wikipedia.org/wiki/User_Datagram_Protocol" target="_blank" rel="noopener noreferrer">UDP</a> protocol</li></ul><h2 class="anchor anchorWithStickyNavbar_mojV" id="details">Details<a class="hash-link" href="#details" title="見出しへの直接リンク">​</a></h2><ul><li><em>How do nodes know each other?</em>: This is unspecified by this ADR and left for future work, it is assumed that a Hydra node operator knows the IP:Port address of its peers before opening a Head with them</li><li><em>Are messages encrypted?</em>: This should probably be the case in order to ensure Heads' privacy but is also left for future work</li><li><em>How are nodes identified?</em>: At the moment they are identified by their IP:Port pair. As we implement more of the setup process from section 4 of the Hydra Head paper, we should identify nodes by some public key(hash) and resolve the actual IP:Port pair using some other mechanism</li></ul><h2 class="anchor anchorWithStickyNavbar_mojV" id="consequences">Consequences<a class="hash-link" href="#consequences" title="見出しへの直接リンク">​</a></h2><ul><li>Node's <em>HeadLogic</em> handles lost, duplicates, and out-of-order messages using <em>retry</em> and <em>timeout</em> mechanisms</li><li>Messages should carry a unique identifier, eg. source node and index</li><li>Protocol, eg. messages format, is documented</li></ul>]]></content>
        <category label="Draft" term="Draft"/>
    </entry>
    <entry>
        <title type="html"><![CDATA[18. Single state in Hydra.Node.
]]></title>
        <id>18</id>
        <link href="https://input-output-hk.github.io/head-protocol/ja/adr/18"/>
        <updated>2022-04-13T00:00:00.000Z</updated>
        <summary type="html"><![CDATA[Status]]></summary>
        <content type="html"><![CDATA[<h2 class="anchor anchorWithStickyNavbar_mojV" id="status">Status<a class="hash-link" href="#status" title="見出しへの直接リンク">​</a></h2><p>Proposed</p><h2 class="anchor anchorWithStickyNavbar_mojV" id="context">Context<a class="hash-link" href="#context" title="見出しへの直接リンク">​</a></h2><ul><li>Currently the <code>hydra-node</code> maintains two pieces of state during the life-cycle of a Hydra Head:<ol><li>A <code>HeadState tx</code> provided by the <code>HydraHead tx m</code> handle interface and part of the <code>Hydra.Node</code> module. It provides the basis for the main <code>hydra-node</code> business logic in <code>Hydra.Node.processNextEvent</code> and <code>Hydra.HeadLogic.update</code><a href="https://github.com/input-output-hk/hydra-poc/blob/a98e2907c4e425de2736782793383aad63132c14/hydra-node/src/Hydra/Node.hs#L256-L257" target="_blank" rel="noopener noreferrer">Creation</a>, <a href="https://github.com/input-output-hk/hydra-poc/blob/a98e2907c4e425de2736782793383aad63132c14/hydra-node/src/Hydra/Node.hs#L174" target="_blank" rel="noopener noreferrer">Usage</a></li><li><code>SomeOnChainHeadState</code> is kept in the <code>Hydra.Chain.Direct</code> to keep track of the latest known head state, including notable transaction outputs and information how to spend it (e.g. scripts and datums)
<a href="https://github.com/input-output-hk/hydra-poc/blob/a98e2907c4e425de2736782793383aad63132c14/hydra-node/src/Hydra/Chain/Direct.hs#L156-L162" target="_blank" rel="noopener noreferrer">Code</a>, <a href="https://github.com/input-output-hk/hydra-poc/blob/a98e2907c4e425de2736782793383aad63132c14/hydra-node/src/Hydra/Chain/Direct.hs#L449" target="_blank" rel="noopener noreferrer">Usage 1</a>, <a href="https://github.com/input-output-hk/hydra-poc/blob/a98e2907c4e425de2736782793383aad63132c14/hydra-node/src/Hydra/Chain/Direct.hs#L414" target="_blank" rel="noopener noreferrer">Usage 2</a>, <a href="https://github.com/input-output-hk/hydra-poc/blob/a98e2907c4e425de2736782793383aad63132c14/hydra-node/src/Hydra/Chain/Direct.hs#L349-L352" target="_blank" rel="noopener noreferrer">Usage 3</a>
(There are other unrelated things kept in memory like the event history in the API server or a peer map in the network heartbeat component.)</li></ol></li><li>The interface between the <code>Hydra.Node</code> and a <code>Hydra.Chain</code> component consists of <ul><li>constructing certain Head protocol transactions given a description of it (<code>PostChainTx tx</code>):<div class="codeBlockContainer_I0IT language-hs theme-code-block"><div class="codeBlockContent_wNvx hs"><pre tabindex="0" class="prism-code language-hs codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">postTx :: MonadThrow m =&gt; PostChainTx tx -&gt; m ()</span><br></span></code></pre><button type="button" aria-label="クリップボードにコードをコピー" class="copyButton_wuS7 clean-btn">コピー</button></div></div></li><li>a callback function when the <code>Hydra.Chain</code> component observed a new Head protocol transaction described by <code>OnChainTx tx</code>:<div class="codeBlockContainer_I0IT language-hs theme-code-block"><div class="codeBlockContent_wNvx hs"><pre tabindex="0" class="prism-code language-hs codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">type ChainCallback tx m = OnChainTx tx -&gt; m ()</span><br></span></code></pre><button type="button" aria-label="クリップボードにコードをコピー" class="copyButton_wuS7 clean-btn">コピー</button></div></div></li></ul></li><li>Given by the usage sites above, the <code>Hydra.Chain.Direct</code> module requires additional info to do both, construct protocol transactions with <code>postTx</code> as well as observe potential <code>OnChainTx</code> (<a href="https://github.com/input-output-hk/hydra-poc/blob/a98e2907c4e425de2736782793383aad63132c14/hydra-node/src/Hydra/Chain/Direct.hs#L333-L336" target="_blank" rel="noopener noreferrer">here</a>). Hence we see that, operation of the <code>Hydra.Chain.Direct</code> component (and likely any implementing the interface fully) is <strong>inherently stateful</strong>.</li><li>We are looking at upcoming features to <a href="https://github.com/input-output-hk/hydra-poc/issues/185" target="_blank" rel="noopener noreferrer">handle rollbacks</a> and dealing with <a href="https://github.com/input-output-hk/hydra-poc/issues/187" target="_blank" rel="noopener noreferrer">persisting the head state</a>.<ul><li>Both could benefit from the idea, that the <code>HeadState</code> is just a result of pure <code>Event</code> processing (a.k.a event sourcing).</li><li>Right now the <code>HeadState</code> kept in <code>Hydra.Node</code> alone, is not enough to fully describe the state of the <code>hydra-node</code>. Hence it would not be enough to just persist all the <code>Event</code>s and replaying them to achieve persistence, nor resetting to some previous <code>HeadState</code> in the presence of a rollback.</li></ul></li></ul><h2 class="anchor anchorWithStickyNavbar_mojV" id="decision">Decision<a class="hash-link" href="#decision" title="見出しへの直接リンク">​</a></h2><ul><li>We define and keep a "blackbox" <code>ChainState tx</code> in the <code>HeadState tx</code><ul><li>It shall not be introspectable to the business logic in <code>HeadLogic</code></li><li>It shall contain chain-specific information about the current Hydra Head, which will naturally need to evolve once we have multiple Heads in our feature scope</li><li>For example:</li></ul><div class="codeBlockContainer_I0IT language-hs theme-code-block"><div class="codeBlockContent_wNvx hs"><pre tabindex="0" class="prism-code language-hs codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">data HeadState tx</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  = IdleState</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  | InitialState</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      { chainState :: ChainState tx</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      -- ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  | OpenState</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      { chainState :: ChainState tx</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      -- ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  | ClosedState</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      { chainState :: ChainState tx</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      -- ...</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      }</span><br></span></code></pre><button type="button" aria-label="クリップボードにコードをコピー" class="copyButton_wuS7 clean-btn">コピー</button></div></div></li><li>We provide the latest <code>ChainState tx</code> to <code>postTx</code>:<div class="codeBlockContainer_I0IT language-hs theme-code-block"><div class="codeBlockContent_wNvx hs"><pre tabindex="0" class="prism-code language-hs codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">postTx :: ChainState tx -&gt; PostChainTx tx -&gt; m ()</span><br></span></code></pre><button type="button" aria-label="クリップボードにコードをコピー" class="copyButton_wuS7 clean-btn">コピー</button></div></div></li><li>We change the callback interface of <code>Chain</code> to<div class="codeBlockContainer_I0IT language-hs theme-code-block"><div class="codeBlockContent_wNvx hs"><pre tabindex="0" class="prism-code language-hs codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">type ChainCallback tx m = (ChainState tx -&gt; Maybe (OnChainTx tx, ChainState tx)) -&gt; m ()</span><br></span></code></pre><button type="button" aria-label="クリップボードにコードをコピー" class="copyButton_wuS7 clean-btn">コピー</button></div></div>with the meaning, that invoking the callback indicates receival of a potential Hydra transaction which is <code>Maybe</code> observing a relevant <code>OnChainTx tx</code> paired with a (potentially updated) <code>ChainState tx</code>.</li><li>We also decide to extend <code>OnChainEvent</code> and <code>OnChainEffect</code> with a <code>ChainState tx</code> and threading it through the <code>Hydra.HeadLogic</code>.</li></ul><h2 class="anchor anchorWithStickyNavbar_mojV" id="consequences">Consequences<a class="hash-link" href="#consequences" title="見出しへの直接リンク">​</a></h2><ul><li>We need to change the construction of <code>Chain</code> handles and the call sites of <code>postTx</code></li><li>We need to extract the state handling (similar to the event queue) out of the <code>HydraNode</code> handle and shuffle the main of <code>hydra-node</code> a bit to be able to provide the latest <code>ChainState</code> to the chain callback as a continuation.</li><li>We need to make the <code>ChainState</code> already serializable (<code>ToJSON</code>, <code>FromJSON</code>) as it will be part of the <code>HeadState</code>.</li><li>We can drop the <code>TVar</code> of keeping <code>OnChainHeadState</code> in the <code>Hydra.Chain.Direct</code> module.</li><li>We might be able to simplify the <code>ChainState tx</code> to be just a <code>UTxOType tx</code> later.</li></ul><h2 class="anchor anchorWithStickyNavbar_mojV" id="alternative">Alternative<a class="hash-link" href="#alternative" title="見出しへの直接リンク">​</a></h2><ul><li>We could extend <code>PostChainTx</code> and <code>OnChainTx</code> with <code>ChainState</code> and keep the signatures:</li></ul><div class="codeBlockContainer_I0IT language-hs theme-code-block"><div class="codeBlockContent_wNvx hs"><pre tabindex="0" class="prism-code language-hs codeBlock_jd64 thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_mRuA"><span class="token-line" style="color:#393A34"><span class="token plain">postTx :: MonadThrow m =&gt; PostChainTx tx -&gt; m ()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">type ChainCallback tx m = (ChainState tx -&gt; Maybe (OnChainTx tx) -&gt; m ()</span><br></span></code></pre><button type="button" aria-label="クリップボードにコードをコピー" class="copyButton_wuS7 clean-btn">コピー</button></div></div><ul><li>Consequences:<ul><li>We need to change the interface between <code>Hydra.Chain.Direct.Tx</code> and <code>Hydra.Chain.Direct.State</code> to something else than <code>OnChainTx</code> as the former would not have a suitable <code>ChainState</code> to construct, e.g. <code>observeInitTx</code> would return <code>Maybe InitObervation</code>. This may be an orthogonally desired change though.</li><li>Traces (e.g. <code>ToPost</code>) and errors (e.g. <code>PostTxError</code>) would automatically include the full <code>ChainState</code>, which might be helpful but also possible big.</li></ul></li></ul>]]></content>
        <category label="Proposed" term="Proposed"/>
    </entry>
</feed>